# Второй способ предполагает использование файла bomb когда мы зашли на сервер.
### Сперва надо войти на сервер, описание в writeup1.md.
Входим на сервер
``ssh laurie@172.16.101.128``
``login: laurie``
``password: 330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4``
Делаем проверку того что лежит на сервере.
``ls``
Файл bomb это бинарник, при запуске нужно пройти несколько фаз для дешифровки.
## Играем в bomb.
Первым делом делаем ``nm bomb`` для получения таблиц имен бинарника.
![
08048b20 T phase_1
08048b48 T phase_2
08048b98 T phase_3
08048ce0 T phase_4
08048d2c T phase_5
08048d98 T phase_6
](/imgs/img2_1.png)

### Расшифровка первой фазы.
Для расшифроки нам потребуется дебагер ``gbd``, его мы используем на всех фазах.
``gdb ./bomb``
``(gdb) disass phase_1``

![
0x08048b32 <+18>:	call   0x8049030 <strings_not_equal>
](/imgs/img2_2.png)

Нам нужна вот эта строка ``0x08048b32 <+18>:	call   0x8049030 <strings_not_equal>``, а точнее ее адрес.
``(gdb) x/s 0x80497c0`` -> ``"Public speaking is very easy."``
Первая фаза пройдена.
### Расшифровка второй фазы.
``(gdb) disass phase_2``
![
0x08048b5b <+19>:	call   0x8048fd8 <read_six_numbers>
](/imgs/img2_3.png)
Нам нужна вот эта строка ``0x08048b5b <+19>:	call   0x8048fd8 <read_six_numbers>``, а точнее ее адрес.
``(gdb) x/s 0x08049b1b`` -> ``"%d %d %d %d %d %d"``
Теперь мы знаем что оно должно на вход получить 6 цифр.
На этой строке ``0x08048b63 <+27>:	cmpl   $0x1,-0x18(%ebp)`` идет сравнение, равняется ли первое число единице. Значит первое значение 1. Дальше простым подбором определяем следующие значения.
Значения 
``1 - 1``
``2 - 2``
``3 - 6``
``4 - 24``
На этом этапе можно определить логику по которой строятся цифры.
``1 - 1`` -> ``1 * 1 = 1``
``2 - 2`` -> ``1 * 2 = 2``
``3 - 6`` -> ``2 * 3 = 6``
``4 - 24`` -> ``6 * 4 = 24``
``5 - 120`` -> ``24 * 5 = 120``
``6 - 720`` -> ``120 * 6 = 720``
Вторая фаза пройдена.
### Расшифровка третьей фазы.
``(gdb) disass phase_3``
![
0x08048bb7 <+31>:	call   0x8048860 <sscanf@plt>
](/imgs/img2_4.png)

Нам нужна эта строка ``0x08048bb7 <+31>:	call   0x8048860 <sscanf@plt>``, в которую идет запись на вот этой строке ``0x08048bb1 <+25>:	push   $0x80497de``
``(gdb) x/s 0x80497de`` -> ``"%d %c %d"``.
Открыв ридми можно узнать что нам нужен символ `b`.
В итоге у нас получается найти вариант ``1 b 214``. Так же были варианты ``7 b 524	`` и ``2 b 755`` но они не подошли.
Третья фаза пройдена.
### Расшифровка четвертой фазы.
``(gdb) disass phase_4``
![
0x08048cf6 <+22>:	call   0x8048860 <sscanf@plt>
](/imgs/img2_5.png)

Делаем то же что делали на третьем шаге. 
Нам нужна эта строка ``0x08048cf6 <+22>:	call   0x8048860 <sscanf@plt>``
В нее идет запись с этой строки ``0x08048cf0 <+16>:	push   $0x8049808``
``(gdb) x/s 0x8049808`` -> ``"%d"``
Пробуем разные варианты, ``42`` а также от ``1`` до ``10``. Сработало, нужный нам вариант ``9``.
Четверный этап пройден.
### Расшифровка пятой фазы.
``(gdb) disass phase_5``
![
0x08048d3b <+15>:	call   0x8049018 <string_length>
0x08048d40 <+20>:	add    $0x10,%esp
0x08048d43 <+23>:	cmp    $0x6,%eax
](/imgs/img2_6.png)

Здесь немного почитав можно прийти к выводу что на этом этапе от нас требуют строку длиной в 6 символов.

Идем дальше ``0x08048d7b <+79>:	call   0x8049030 <strings_not_equal>``.
``(gdb) x/s 0x804980b`` -> ``giants``
Идем дальше ``0x08048d52 <+38>:	mov    $0x804b220``
``(gdb) x/s 0x804b220`` -> ``"isrveawhobpnutfg\260\001"``
Теперь у нас есть паттерн и строка которую надо расшифровать паттерном, после
долгих часов поисков получаем результат - ``opekmq``
Идея в том что в обоих словах по 6 символов, если сравнить строку 
``_abcdefghijklmno``
``pqrstuvwxyz``
``isrveawhobpnutfg``
`g` -> `o`
`i` -> `p`
`a` -> `e`
`n` -> `k`
`t` -> `m`
`s` -> `q`
Расшифровка пятой фазы завершена.

### Расшифровка шестой фазы.
``(gdb) disass phase_6``
![
0x08048db3 <+27>:	call   0x8048fd8 <read_six_numbers>
](/imgs/img2_7.png)

Нужная нам строка ``0x08048db3 <+27>:	call   0x8048fd8 <read_six_numbers>``, теперь мы знаем что от нас требуют 6 цифр. Почитав как устроен механизм можно понять что там задан массив от 1 до 6, а проверка инпута происходит по индексам массива 1 - 6. Таким образом, правильный ответ ``4 2 6 3 1 5``.
Расшифровка шестой фазы закончена.






























